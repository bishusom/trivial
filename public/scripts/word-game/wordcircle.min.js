// wordcircle.min.js
export function initWordGame() {
    // Load saved state
    const savedState = loadGameState();
    let difficulty = savedState?.difficulty || 'easy';
    let consecutiveWins = savedState?.consecutiveWins || 0;
    let currentLevel = savedState?.currentLevel || 1;

    // Game configuration
    const config = {
        easy: { letterCount: 6, minWordLength: 3, maxWordLength: 5, wordCount: 6, difficulty: 'easy' },
        medium: { letterCount: 7, minWordLength: 4, maxWordLength: 6, wordCount: 8, difficulty: 'medium' },
        hard: { letterCount: 8, minWordLength: 4, maxWordLength: 7, wordCount: 10, difficulty: 'hard' }
    };

    // Game state
    let letters = []; // The pool of letters for the puzzle (e.g., ['P', 'I', 'P', 'L', 'R', 'G'])
    let words = [];   // The target words for the puzzle (e.g., ['PIP', 'MIL', 'GIGI'])
    let foundWords = new Set(); // Use a Set for quick lookup of found words
    let selectedLettersSequence = []; // Stores indices of selected letters in the sequence drawn (for drawing path)
    let currentWord = ''; // The word currently being formed by drawing
    let usedWordsInGame = new Set(); // Words used in this specific game session (to avoid repetition in subsequent games)

    // Drawing state
    let isDrawing = false;
    let currentLine = null; // SVG polyline element for the current line being drawn
    let svgElement = null; // Reference to the SVG element for drawing
    let letterElements = []; // Store references to letter DOM elements for easy access
    let availableLettersForCurrentWord = {}; // NEW: Temporary map of letter counts available for the current word being drawn
    let currentWordLetterElements = []; // NEW: Store references to letter DOM elements used in the *current* word being drawn for visual reset

    // DOM elements
    const lettersContainer = document.getElementById('wordcircle-letters-container');
    const lettersElement = document.getElementById('wordcircle-letters');
    const crosswordGridElement = document.getElementById('crossword-grid'); // NEW: Reference to the crossword grid
    const wordsLeftElement = document.getElementById('wordcircle-words-left');
    const currentWordElement = document.getElementById('current-word');
    let feedbackElement = document.getElementById('wordcircle-feedback');
    const newGameBtn = document.getElementById('wordcircle-new');
    const hintBtn = document.getElementById('wordcircle-hint');
    const shuffleBtn = document.getElementById('wordcircle-shuffle');
    const checkPuzzleBtn = document.getElementById('wordcircle-check-puzzle'); // NEW: Check Puzzle button
    const levelElement = document.getElementById('wordcircle-level');
    const gamesRemainingElement = document.getElementById('wordcircle-games-remaining');
    const muteBtnIcon = document.querySelector('#mute-btn .material-icons');

    // Sound effects
    const audioElements = {
        select: new Audio('/audio/click.mp3'),
        found: new Audio('/audio/correct.mp3'),
        win: new Audio('/audio/win.mp3'),
        error: new Audio('/audio/wrong.mp3')
    };

    // Mute state
    let isMuted = JSON.parse(localStorage.getItem('triviaMasterMuteState')) || false;

    // Sound functions
    function playSound(type) {
        if (isMuted) return;
        if (audioElements[type]) {
            audioElements[type].currentTime = 0;
            audioElements[type].play().catch(err => console.error(`Error playing ${type} sound:`, err));
        }
    }

    function stopAllSounds() {
        Object.keys(audioElements).forEach(type => {
            audioElements[type].pause();
            audioElements[type].currentTime = 0;
        });
    }

    function loadMuteState() {
        isMuted = JSON.parse(localStorage.getItem('triviaMasterMuteState')) || false;
        if (muteBtnIcon) {
            muteBtnIcon.textContent = isMuted ? 'volume_off' : 'volume_up';
        }
        if (isMuted) stopAllSounds();
    }

    // Game state functions
    function saveGameState() {
        const gameState = { difficulty, consecutiveWins, currentLevel };
        localStorage.setItem('wordCircleState', JSON.stringify(gameState));
    }

    function loadGameState() {
        const savedState = localStorage.getItem('wordCircleState');
        return savedState ? JSON.parse(savedState) : null;
    }

    /**
     * Fetches a pre-validated puzzle from the 'wordCirclePuzzles' Firestore collection.
     * Selects a random puzzle based on difficulty and a randomIndex.
     * @param {object} diffConfig - The configuration object for the current difficulty (e.g., config.easy).
     * @returns {Promise<Array<Object>>} A promise that resolves to an array of word objects.
     */
    async function fetchPuzzle(diffConfig) {
        try {
            // Ensure Firebase 'db' object is accessible.
            if (typeof db === 'undefined' || !db.collection) {
                console.error("Firebase 'db' object is not defined. Ensure Firebase is initialized.");
                throw new Error("Firebase not initialized for puzzle fetch.");
            }

            // Generate a random anchor point for efficient random selection from the collection.
            const randomAnchor = Math.floor(Math.random() * 1000000); // Assuming randomIndex from 0 to 999,999

            let puzzleDoc = null;
            // Attempt to get a puzzle document after the random anchor
            const querySnapshot1 = await db.collection('wordCirclePuzzles')
                .where('difficulty', '==', diffConfig.difficulty)
                .where('randomIndex', '>=', randomAnchor)
                .orderBy('randomIndex')
                .limit(1)
                .get();

            if (!querySnapshot1.empty) {
                puzzleDoc = querySnapshot1.docs[0].data();
            } else {
                // If no puzzle found after the random anchor, try from the beginning of the collection
                const querySnapshot2 = await db.collection('wordCirclePuzzles')
                    .where('difficulty', '==', diffConfig.difficulty)
                    .orderBy('randomIndex')
                    .limit(1)
                    .get();
                if (!querySnapshot2.empty) {
                    puzzleDoc = querySnapshot2.docs[0].data();
                }
            }

            if (!puzzleDoc || !Array.isArray(puzzleDoc.words) || !Array.isArray(puzzleDoc.letters)) {
                console.warn(`Fetched puzzle is malformed or not found for difficulty: ${diffConfig.difficulty}. Triggering fallback.`);
                throw new Error(`Malformed or missing puzzle for difficulty: ${diffConfig.difficulty}`);
            }

            // Populate the global 'letters' array directly from the fetched puzzle's letters
            // It's good practice to shuffle them for presentation randomness, even if pre-shuffled.
            letters = shuffleArray(puzzleDoc.letters.map(l => l.toUpperCase())); 

            // Return the words for the game's 'words' state.
            // Map them to the expected { word: "WORD", letters: ["W", "O", "R", "D"] } format.
            return puzzleDoc.words.map(word => ({ word: word.toUpperCase(), letters: word.toUpperCase().split('') }));

        } catch (error) {
            console.error("Error fetching puzzle from Firebase, using static fallback:", error);
            // Fallback to static words if Firebase fails or no suitable puzzle is found
            const staticWords = [
                'CAT', 'HAT', 'RAT', 'MAT', 'PAT', 'SAT',
                'DOG', 'LOG', 'FOG', 'HOG', 'JOG', 'BOG',
                'PEN', 'MEN', 'TEN', 'DEN', 'HEN', 'KEN'
            ].filter(word => word.length >= diffConfig.minWordLength && word.length <= diffConfig.maxWordLength);
            
            const uniqueStaticWords = [...new Set(staticWords)]
                .filter(word => !usedWordsInGame.has(word));
            
            const fallbackWordsObjs = shuffleArray(uniqueStaticWords).slice(0, diffConfig.wordCount)
                .map(word => ({ word, letters: word.split('') }));
            
            // For the static fallback, we still need to generate the letters from these words
            // This ensures solvability from a given word list, even for fallback.
            letters = generateLettersForWordList(fallbackWordsObjs, diffConfig.letterCount);

            return fallbackWordsObjs;
        }
    }

    /**
     * Generates a set of letters suitable for forming words in a given list.
     * This function is primarily used by the static fallback.
     * @param {Array<Object>} wordList - Array of word objects { word: "WORD", letters: [...] }.
     * @param {number} letterCount - The total number of letters required for the puzzle.
     * @returns {Array<string>} An array of letters (characters).
     */
    function generateLettersForWordList(wordList, letterCount) {
        const maxRequiredLetterCounts = {}; 
        wordList.forEach(wordObj => {
            const currentWordLetterCounts = {};
            wordObj.letters.forEach(letter => {
                currentWordLetterCounts[letter] = (currentWordLetterCounts[letter] || 0) + 1;
            });

            Object.keys(currentWordLetterCounts).forEach(letter => {
                maxRequiredLetterCounts[letter] = Math.max(
                    maxRequiredLetterCounts[letter] || 0,
                    currentWordLetterCounts[letter]
                );
            });
        });

        let selected = [];
        for (const letter in maxRequiredLetterCounts) {
            for (let i = 0; i < maxRequiredLetterCounts[letter]; i++) {
                if (selected.length < letterCount) {
                    selected.push(letter);
                } else {
                    console.warn(`(Fallback) Cannot include all required instances of letter '${letter}'. Letter count budget exceeded.`);
                    break; 
                }
            }
        }

        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        while (selected.length < letterCount) {
            const remaining = alphabet.filter(l => !selected.includes(l));
            if (remaining.length > 0) {
                const randomLetter = remaining[Math.floor(Math.random() * remaining.length)];
                selected.push(randomLetter);
            } else {
                break; 
            }
        }
        
        return shuffleArray(selected);
    }

    /**
     * Checks if a given list of words can be formed using a given set of available letters.
     * Primarily used by the static fallback to ensure puzzle solvability.
     * @param {Array<Object>} wordList - Array of word objects { word: "WORD", letters: [...] }.
     * @param {Array<string>} availableLetters - The letters available for forming words.
     * @returns {boolean} True if all words can be formed, false otherwise.
     */
    function canFormWords(wordList, availableLetters) {
        const letterCounts = {};
        availableLetters.forEach(letter => {
            letterCounts[letter] = (letterCounts[letter] || 0) + 1;
        });

        return wordList.every(wordObj => {
            const tempCounts = { ...letterCounts }; 
            const wordLetterCounts = {};
            wordObj.letters.forEach(letter => {
                wordLetterCounts[letter] = (wordLetterCounts[letter] || 0) + 1;
            });

            return Object.keys(wordLetterCounts).every(letter => {
                if (!tempCounts[letter] || tempCounts[letter] < wordLetterCounts[letter]) {
                    return false;
                }
                tempCounts[letter] -= wordLetterCounts[letter];
                return true;
            });
        });
    }

    // Game initialization
    async function initGame() {
        showLoadingAnimation();
        // Get SVG element reference
        svgElement = document.getElementById('wordcircle-drawing-svg');
        if (!svgElement) {
            console.error("SVG element 'wordcircle-drawing-svg' not found! Ensure it's in your HTML.");
            showFinalErrorAnimation();
            return;
        }
        svgElement.innerHTML = ''; // Clear any old lines

        lettersElement.innerHTML = '';
        crosswordGridElement.innerHTML = ''; // NEW: Clear crossword grid
        currentWordElement.innerHTML = '';
        selectedLettersSequence = []; 
        foundWords.clear(); // Reset found words set
        currentWord = '';
        usedWordsInGame.clear(); 

        updateLevelInfo();
        try {
            words = await fetchPuzzle(config[difficulty]); 
            console.log('Words fetched from Firestore:', words.map(w => w.word));
            console.log('Letters provided for puzzle:', letters); 

            renderLetters(); 
            renderCrossword(); // NEW: Render the crossword grid
            updateWordsLeft();
            showFeedback(`Form ${words.length} words using these letters!`, 'info');
        } catch (error) {
            console.error("Game initialization failed:", error);
            showFinalErrorAnimation();
        }
    }

    // Rendering functions
    function renderLetters() {
        lettersElement.innerHTML = '';
        letterElements = []; 
        const radius = 100; 
        const centerX = 150; 
        const centerY = 150; 
        const letterSize = 50; 
        const angleStep = (2 * Math.PI) / letters.length;

        letters.forEach((letter, index) => {
            const angle = index * angleStep;
            const x = centerX + radius * Math.cos(angle) - (letterSize / 2);
            const y = centerY + radius * Math.sin(angle) - (letterSize / 2);

            const letterElement = document.createElement('div');
            letterElement.className = 'wordcircle-letter';
            letterElement.textContent = letter;
            letterElement.dataset.letter = letter;
            letterElement.dataset.index = index; 
            letterElement.style.left = `${x}px`;
            letterElement.style.top = `${y}px`;
            
            lettersElement.appendChild(letterElement);
            letterElements.push(letterElement);
        });
    }

    /**
     * Renders the crossword-like grid, displaying target words as rows of cells.
     * Some cells are pre-filled as hints. Found words are fully revealed.
     */
    function renderCrossword() {
        crosswordGridElement.innerHTML = ''; // Clear existing crossword
        const sortedWords = [...words].sort((a, b) => a.word.length - b.word.length); // Sort by length for display

        sortedWords.forEach((wordObj, wordIndex) => {
            const wordRow = document.createElement('div');
            wordRow.className = 'crossword-word-row';
            wordRow.dataset.word = wordObj.word; // Store the full word for easy lookup

            const isWordFound = foundWords.has(wordObj.word);
            
            // Determine how many letters to reveal initially as hints
            // Roughly 30% of letters, rounded down, but at least one for short words
            const hintCount = Math.max(1, Math.floor(wordObj.word.length * 0.3)); 
            const hintIndices = new Set();
            const indices = Array.from({ length: wordObj.word.length }, (_, i) => i);
            const shuffledIndices = shuffleArray(indices);

            for (let i = 0; i < hintCount; i++) {
                hintIndices.add(shuffledIndices[i]);
            }

            wordObj.letters.forEach((letter, letterIndex) => {
                const cell = document.createElement('div');
                cell.className = 'crossword-cell';
                cell.dataset.letter = letter; // Store actual letter

                if (isWordFound || hintIndices.has(letterIndex)) {
                    cell.textContent = letter;
                    cell.classList.add('filled');
                } else {
                    cell.textContent = ''; // Blank for user to fill
                }
                wordRow.appendChild(cell);
            });
            crosswordGridElement.appendChild(wordRow);
        });
    }

    /**
     * Updates a specific word row in the crossword grid when a word is found.
     * @param {string} word - The word that was found.
     */
    function updateCrosswordWord(word) {
        const wordRow = crosswordGridElement.querySelector(`.crossword-word-row[data-word="${word}"]`);
        if (wordRow) {
            Array.from(wordRow.children).forEach((cell, index) => {
                cell.textContent = word[index];
                cell.classList.add('filled');
            });
        }
    }


    // --- Drawing Event Handlers ---

    // Helper to get coordinates relative to the lettersContainer
    function getEventCoords(e) {
        let clientX, clientY;
        // Handle both mouse and touch events
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        const rect = lettersContainer.getBoundingClientRect(); // Get bounding rect of the container
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        return { x, y };
    }

    // Helper to get the center coordinates of a letter element
    function getLetterCenter(letterIndex) {
        const letterEl = letterElements[letterIndex];
        if (!letterEl) return null;
        const rect = letterEl.getBoundingClientRect();
        const containerRect = lettersContainer.getBoundingClientRect();
        const centerX = (rect.left + rect.width / 2) - containerRect.left;
        const centerY = (rect.top + rect.height / 2) - containerRect.top;
        return { x: centerX, y: centerY };
    }

    function handleDrawStart(e) {
        if (e.button === 2) return; // Ignore right-click

        e.preventDefault(); // Prevent default browser actions (e.g., scrolling on touch)
        isDrawing = true;
        clearSelection(); // Clears currentWord and selectedLettersSequence
        clearSelectionUI(); // Clears lines and removes 'selected'/'active-drag' classes

        // NEW: Initialize available letters for this drawing attempt
        availableLettersForCurrentWord = {};
        letters.forEach(letter => {
            availableLettersForCurrentWord[letter] = (availableLettersForCurrentWord[letter] || 0) + 1;
        });
        currentWordLetterElements = []; // Reset visual tracking of selected elements
        
        currentLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        currentLine.setAttribute('class', 'drawn-line');
        svgElement.appendChild(currentLine);

        const targetLetterElement = e.target.closest('.wordcircle-letter');
        if (targetLetterElement) {
            const letterChar = targetLetterElement.dataset.letter;
            const index = parseInt(targetLetterElement.dataset.index);

            // NEW: Check if the letter is available in the temporary pool
            if (availableLettersForCurrentWord[letterChar] > 0) {
                addLetterToCurrentWord(letterChar, index, targetLetterElement); // Pass char, index, element
                
                const center = getLetterCenter(index);
                if (center) {
                    currentLine.setAttribute('points', `${center.x},${center.y}`);
                    const { x, y } = getEventCoords(e);
                    currentLine.setAttribute('points', `${center.x},${center.y} ${x},${y}`);
                }
            } else {
                 console.warn(`Cannot start word: letter ${letterChar} not available.`);
                 isDrawing = false; 
                 currentLine.remove(); 
            }
        } else {
            // If drawing starts outside a letter, just start drawing from current mouse position
            const { x, y } = getEventCoords(e);
            currentLine.setAttribute('points', `${x},${y}`);
        }
    }

    function handleDrawMove(e) {
        if (!isDrawing || !currentLine) return;
        e.preventDefault();

        const { x, y } = getEventCoords(e);
        
        let points = currentLine.getAttribute('points').split(' ');
        if (points.length === 0) return; 

        points[points.length - 1] = `${x},${y}`;
        currentLine.setAttribute('points', points.join(' '));

        const targetElement = document.elementFromPoint(e.clientX, e.clientY);
        const targetLetterElement = targetElement?.closest('.wordcircle-letter');

        if (targetLetterElement) {
            const letterChar = targetLetterElement.dataset.letter;
            const index = parseInt(targetLetterElement.dataset.index);

            // NEW: Logic to allow re-selection of letters by character
            // Check if this letter is available in the temporary pool
            // And ensure it's not the exact *last* letter element clicked (to prevent accidental double-adding if mouse jitters)
            const lastSelectedIndex = selectedLettersSequence[selectedLettersSequence.length - 1];
            if (availableLettersForCurrentWord[letterChar] > 0 && lastSelectedIndex !== index) {
                addLetterToCurrentWord(letterChar, index, targetLetterElement);
                playSound('select'); 

                const newLetterCenter = getLetterCenter(index);
                if (newLetterCenter) {
                    points.pop();
                    points.push(`${newLetterCenter.x},${newLetterCenter.y}`);
                    points.push(`${x},${y}`);
                    currentLine.setAttribute('points', points.join(' '));
                }
            }
        }
    }

    function handleDrawEnd(e) {
        if (!isDrawing) return;
        isDrawing = false;
        e.preventDefault();
        
        if (currentLine) {
            let points = currentLine.getAttribute('points').split(' ');
            if (points.length > 1) { 
                points.pop();
                currentLine.setAttribute('points', points.join(' '));
            } else {
                currentLine.remove();
            }
        }

        if (currentWord.length > 0) {
            handleSubmit(); // Automatically submit the drawn word
        } else {
            clearSelectionUI();
        }
    }

    // Adds a letter to the current word being formed and updates its visual state
    function addLetterToCurrentWord(char, index, element) {
        if (availableLettersForCurrentWord[char] > 0) {
            selectedLettersSequence.push(index); 
            currentWord += char; 
            
            element.classList.add('selected'); 
            element.classList.add('active-drag'); 

            availableLettersForCurrentWord[char]--; // Decrement count for this letter

            currentWordLetterElements.push(element);

            updateCurrentWord();
        } else {
            console.warn(`Attempted to use letter '${char}' more times than available in the current puzzle's pool.`);
        }
    }

    // Resets the game state variables for the current selection (letters, word)
    function clearSelection() {
        selectedLettersSequence = []; 
        currentWord = '';
        // Reset availableLettersForCurrentWord only when a new word is started, not just clearing.
        // It's re-initialized in handleDrawStart.
        currentWordLetterElements = []; 
        updateCurrentWord();
    }

    // Resets the UI for the current selection (removes classes, clears SVG lines)
    function clearSelectionUI() {
        currentWordLetterElements.forEach(el => {
            el.classList.remove('selected', 'active-drag'); 
        });
        currentWordLetterElements = []; 

        if (svgElement) {
            svgElement.innerHTML = ''; 
        }
    }

    /**
     * Handles submission of the drawn word.
     * Checks if the word is valid, not already found, and updates UI/game state.
     */
    function handleSubmit() {
        const word = currentWord.toUpperCase();
        if (word.length < config[difficulty].minWordLength) {
            showFeedback('Word too short!', 'error');
            playSound('error');
            return; 
        }

        const matchedWordObj = words.find(wordObj => wordObj.word === word);
        if (matchedWordObj && !foundWords.has(word)) { // Use .has() for Set
            foundWords.add(word); // Add to Set
            playSound('found');
            updateCrosswordWord(word); // NEW: Update crossword display
            showFeedback(`Found: ${word}`, 'success');
            updateWordsLeft();
            // Game win check is now handled by `checkAllCrosswordWords` upon user trigger
        } else if (foundWords.has(word)) { // Already found
            showFeedback(`Already found: ${word}`, 'info');
        } else { // Invalid word
            showFeedback('Invalid word!', 'error');
            playSound('error');
        }
        clearSelection(); 
    }

    // Handles shuffling the letters
    function handleShuffle() {
        letters = shuffleArray(letters);
        renderLetters();
        clearSelection();
        clearSelectionUI(); 
    }

    /**
     * NEW: Checks if all words in the crossword have been found.
     * Triggers game win if all words are found.
     */
    function checkAllCrosswordWords() {
        const allWordsFound = words.every(wordObj => foundWords.has(wordObj.word));
        if (allWordsFound) {
            handleGameWin();
        } else {
            showFeedback(`Keep going! ${words.length - foundWords.size} words left to find.`, 'info');
            playSound('error'); // Or a different sound for "not yet complete"
        }
    }

    // Handles game completion (all words found)
    function handleGameWin() {
        playSound('win');
        const victoryScreen = document.createElement('div');
        victoryScreen.className = 'victory-screen';
        showConfetti();

        consecutiveWins++;
        currentLevel++;

        let victoryMessage = '';
        let levelUp = false;

        if (consecutiveWins >= 3) {
            if (difficulty === 'easy') {
                difficulty = 'medium';
                levelUp = true;
                victoryMessage = `üéâ Advanced to Medium level! üéâ`;
            } else if (difficulty === 'medium') {
                difficulty = 'hard';
                levelUp = true;
                victoryMessage = `üèÜ Advanced to Hard level! üèÜ`;
            } else {
                victoryMessage = `üëë Mastered Hard level! üëë`;
            }
            if (levelUp) {
                consecutiveWins = 0;
                setTimeout(() => showConfetti({ particleCount: 200, spread: 100 }), 1000);
            }
        } else {
            victoryMessage = `üéä Level ${currentLevel} Complete! üéä`;
        }

        victoryScreen.innerHTML = `
            <h2>Victory!</h2>
            <p>${victoryMessage}</p>
            <p>Words Found: ${foundWords.size}/${words.length}</p>
            <div class="countdown">Next level in 5...</div>
        `;
        document.body.appendChild(victoryScreen);

        let countdown = 5;
        const countdownElement = victoryScreen.querySelector('.countdown');
        const countdownInterval = setInterval(() => {
            countdown--;
            countdownElement.textContent = `Next level in ${countdown}...`;
            if (countdown <= 0) {
                clearInterval(countdownInterval);
                victoryScreen.remove();
                saveGameState();
                updateLevelInfo();
                initGame(); // Start next level
            }
        }, 1000);
        saveGameState();
    }

    // Utility functions for UI updates and animations
    function updateWordsLeft() {
        wordsLeftElement.textContent = `Words Found: ${foundWords.size}/${words.length}`; // Use .size for Set
    }

    function updateCurrentWord() {
        currentWordElement.textContent = currentWord || ' '; 
    }

    function updateLevelInfo() {
        if (levelElement) {
            levelElement.textContent = `Level: ${currentLevel} (${difficulty})`;
        }
        if (difficulty !== 'hard') {
            const winsNeeded = 3 - consecutiveWins;
            gamesRemainingElement.textContent = winsNeeded > 0
                ? `Wins to next difficulty: ${winsNeeded}`
                : 'Ready to advance difficulty!';
        } else {
            gamesRemainingElement.textContent = 'Max difficulty reached!';
        }
    }

    function showFeedback(message, type) {
        feedbackElement.textContent = message;
        feedbackElement.className = `word-feedback ${type}`;
    }

    function giveHint() {
        const remainingWords = words.filter(wordObj => !foundWords.has(wordObj.word));
        if (remainingWords.length > 0) {
            const hintWordObj = remainingWords[Math.floor(Math.random() * remainingWords.length)];
            const hint = hintWordObj.word.slice(0, 2);
            showFeedback(`Try a word starting with ${hint}...`, 'info');
        } else {
            showFeedback('You found all words! No more hints needed.', 'success');
        }
    }

    function showLoadingAnimation() {
        feedbackElement.innerHTML = `
            <div class="loading-animation">
                <div class="loading-spinner"></div>
                <div class="loading-text">Creating your puzzle</div>
                <div class="loading-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        `;
        feedbackElement.className = 'word-feedback info';
    }

    function showFinalErrorAnimation() {
        feedbackElement.innerHTML = `
            <div class="error-animation">
                <div class="error-icon">‚ùå</div>
                <div>Having trouble loading the game.</div>
                <button class="btn primary" onclick="window.initWordGame()">Try Again</button>
            </div>
        `;
        feedbackElement.className = 'word-feedback error';
    }

    function shuffleArray(array) {
        const result = [...array];
        for (let i = result.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [result[i], result[j]] = [result[j], result[i]];
        }
        return result;
    }

    function showConfetti(options = {}) {
        const defaults = {
            particleCount: 100,
            spread: 70,
            origin: { y: 0.6 },
            colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff']
        };
        if (typeof confetti === 'function') {
            confetti({ ...defaults, ...options });
        } else {
            console.warn("Confetti function not found. Make sure the confetti library is loaded.");
        }
    }

    // --- Event Listeners ---
    newGameBtn.addEventListener('click', initGame);
    hintBtn.addEventListener('click', giveHint);
    shuffleBtn.addEventListener('click', handleShuffle);
    checkPuzzleBtn.addEventListener('click', checkAllCrosswordWords); // NEW: Listen for Check Puzzle button

    if (lettersContainer) {
        lettersContainer.addEventListener('mousedown', handleDrawStart);
        lettersContainer.addEventListener('mousemove', handleDrawMove);
        lettersContainer.addEventListener('mouseup', handleDrawEnd);
        lettersContainer.addEventListener('mouseleave', handleDrawEnd);

        lettersContainer.addEventListener('touchstart', handleDrawStart);
        lettersContainer.addEventListener('touchmove', handleDrawMove);
        lettersContainer.touchend;
        lettersContainer.addEventListener('touchend', handleDrawEnd);
        lettersContainer.addEventListener('touchcancel', handleDrawEnd);
    } else {
        console.error("The 'wordcircle-letters-container' element was not found. Drawing will not work.");
    }

    const muteBtn = document.getElementById('mute-btn');
    if (muteBtn) {
        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            localStorage.setItem('triviaMasterMuteState', isMuted);
            if (muteBtnIcon) {
                muteBtnIcon.textContent = isMuted ? 'volume_off' : 'volume_up';
            }
            if (isMuted) stopAllSounds();
        });
    }

    // --- Initial Game Setup ---
    initGame();
    loadMuteState();
}

document.addEventListener('DOMContentLoaded', () => {
    window.initWordGame = initWordGame; 
    initWordGame();
});